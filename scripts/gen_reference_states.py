#!/usr/bin/env python3
"""
Reference state generator for quantum simulator validation.

This script generates JSON baseline state vectors using Qiskit Aer for validation
of the quantum simulator's state-vector engine. The baselines are deterministic
and can be regenerated byte-for-byte identically.

Requirements:
- Qiskit >= 0.46
- numpy

Usage:
    python scripts/gen_reference_states.py
"""

import json
import os
import sys
from pathlib import Path
from typing import List, Dict, Any, Tuple
import numpy as np

try:
    import qiskit
    from qiskit import QuantumCircuit, transpile
    from qiskit_aer import AerSimulator
    from qiskit.quantum_info import Statevector
    print(f"Using Qiskit version: {qiskit.__version__}")
    
    # Verify Qiskit version >= 0.46
    qiskit_version = tuple(map(int, qiskit.__version__.split('.')[:2]))
    if qiskit_version < (0, 46):
        print(f"ERROR: Qiskit version {qiskit.__version__} < 0.46 required")
        sys.exit(1)
        
except ImportError as e:
    print(f"ERROR: Failed to import Qiskit: {e}")
    print("Please install: pip install qiskit qiskit-aer")
    sys.exit(1)


def complex_to_json_array(state_vector: np.ndarray) -> List[float]:
    """
    Convert complex state vector to JSON-serializable array format.
    
    Format: [real0, imag0, real1, imag1, ...] matching StateVectorResult format.
    
    Args:
        state_vector: Complex numpy array representing quantum state
        
    Returns:
        List of floats in interleaved real/imaginary format
    """
    result = []
    for amplitude in state_vector:
        result.extend([float(amplitude.real), float(amplitude.imag)])
    return result


def generate_canonical_circuits() -> List[Tuple[str, QuantumCircuit, str]]:
    """
    Generate canonical quantum circuits for validation.
    
    Returns:
        List of (name, circuit, description) tuples
    """
    circuits = []
    
    # 1. Identity circuit (2 qubits)
    identity = QuantumCircuit(2)
    circuits.append(("identity_2q", identity, "2-qubit identity circuit |00⟩"))
    
    # 2. Single Hadamard
    hadamard = QuantumCircuit(1)
    hadamard.h(0)
    circuits.append(("hadamard_1q", hadamard, "Single qubit Hadamard |+⟩"))
    
    # 3. Bell state |Φ+⟩ = (|00⟩ + |11⟩)/√2
    bell = QuantumCircuit(2)
    bell.h(0)
    bell.cx(0, 1)
    circuits.append(("bell_state", bell, "Bell state |Φ+⟩"))
    
    # 4. GHZ state |GHZ⟩ = (|000⟩ + |111⟩)/√2
    ghz = QuantumCircuit(3)
    ghz.h(0)
    ghz.cx(0, 1)
    ghz.cx(0, 2)
    circuits.append(("ghz_3q", ghz, "3-qubit GHZ state"))
    
    # 5. W state preparation (approximate)
    w_state = QuantumCircuit(3)
    w_state.ry(np.arccos(np.sqrt(2/3)), 0)
    w_state.cx(0, 1)
    w_state.x(0)
    w_state.ccx(0, 1, 2)
    w_state.x(0)
    circuits.append(("w_3q", w_state, "3-qubit W state"))
    
    # 6. Quantum Fourier Transform (3 qubits)
    qft = QuantumCircuit(3)
    # QFT implementation
    qft.h(0)
    qft.cp(np.pi/2, 1, 0)
    qft.cp(np.pi/4, 2, 0)
    qft.h(1)
    qft.cp(np.pi/2, 2, 1)
    qft.h(2)
    # Swap qubits to get correct order
    qft.swap(0, 2)
    circuits.append(("qft_3q", qft, "3-qubit Quantum Fourier Transform"))
    
    # 7. Toffoli gate test
    toffoli = QuantumCircuit(3)
    toffoli.h(0)
    toffoli.h(1)
    toffoli.ccx(0, 1, 2)
    circuits.append(("toffoli_test", toffoli, "Toffoli gate with superposition controls"))
    
    return circuits


def generate_random_clifford_t_circuits(num_circuits: int = 5, max_qubits: int = 5, max_depth: int = 30, seed: int = 42) -> List[Tuple[str, QuantumCircuit, str]]:
    """
    Generate random Clifford+T circuits for validation.
    
    Args:
        num_circuits: Number of random circuits to generate
        max_qubits: Maximum number of qubits (≤ 5)
        max_depth: Maximum circuit depth (≤ 30)
        seed: Random seed for deterministic generation
        
    Returns:
        List of (name, circuit, description) tuples
    """
    np.random.seed(seed)
    circuits = []
    
    # Clifford+T gate set
    single_qubit_gates = ['h', 'x', 'y', 'z', 's', 'sdg', 't', 'tdg']
    two_qubit_gates = ['cx', 'cz']
    
    for i in range(num_circuits):
        # Random circuit parameters
        num_qubits = np.random.randint(2, max_qubits + 1)
        depth = np.random.randint(5, max_depth + 1)
        
        circuit = QuantumCircuit(num_qubits)
        
        for _ in range(depth):
            # Choose gate type
            if np.random.random() < 0.7:  # 70% single-qubit gates
                gate = np.random.choice(single_qubit_gates)
                qubit = np.random.randint(num_qubits)
                
                if gate == 'h':
                    circuit.h(qubit)
                elif gate == 'x':
                    circuit.x(qubit)
                elif gate == 'y':
                    circuit.y(qubit)
                elif gate == 'z':
                    circuit.z(qubit)
                elif gate == 's':
                    circuit.s(qubit)
                elif gate == 'sdg':
                    circuit.sdg(qubit)
                elif gate == 't':
                    circuit.t(qubit)
                elif gate == 'tdg':
                    circuit.tdg(qubit)
            else:  # 30% two-qubit gates
                if num_qubits > 1:
                    gate = np.random.choice(two_qubit_gates)
                    control = np.random.randint(num_qubits)
                    target = np.random.randint(num_qubits)
                    while target == control:
                        target = np.random.randint(num_qubits)
                    
                    if gate == 'cx':
                        circuit.cx(control, target)
                    elif gate == 'cz':
                        circuit.cz(control, target)
        
        name = f"random_clifford_t_{i+1}"
        description = f"Random Clifford+T circuit ({num_qubits}q, depth {depth})"
        circuits.append((name, circuit, description))
    
    return circuits


def simulate_circuit(circuit: QuantumCircuit) -> np.ndarray:
    """
    Simulate circuit using Qiskit Aer and return final state vector.
    
    Args:
        circuit: Quantum circuit to simulate
        
    Returns:
        Complex numpy array representing the final state vector
    """
    # Use statevector simulator for exact results
    simulator = AerSimulator(method='statevector')
    
    # Add save_statevector instruction to get the final state
    circuit_copy = circuit.copy()
    circuit_copy.save_statevector()
    
    # Transpile circuit for the simulator
    transpiled = transpile(circuit_copy, simulator)
    
    # Run simulation
    job = simulator.run(transpiled, shots=1)
    result = job.result()
    
    # Get statevector from saved data
    statevector = result.get_statevector()
    return statevector.data


def generate_reference_states():
    """
    Generate all reference state JSON files.
    """
    # Ensure output directory exists
    output_dir = Path("core/src/test/resources/reference-states")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print("Generating reference states using Qiskit Aer...")
    
    # Generate canonical circuits
    print("\n1. Generating canonical circuits...")
    canonical_circuits = generate_canonical_circuits()
    
    for name, circuit, description in canonical_circuits:
        print(f"  - {name}: {description}")
        
        # Simulate circuit
        state_vector = simulate_circuit(circuit)
        
        # Convert to JSON format
        amplitudes = complex_to_json_array(state_vector)
        
        # Create metadata
        metadata = {
            "name": name,
            "description": description,
            "num_qubits": circuit.num_qubits,
            "num_gates": len(circuit.data),
            "qiskit_version": qiskit.__version__,
            "circuit_qasm": str(circuit)
        }
        
        # Create JSON structure
        reference_data = {
            "metadata": metadata,
            "amplitudes": amplitudes
        }
        
        # Write to file
        output_file = output_dir / f"{name}.json"
        with open(output_file, 'w') as f:
            json.dump(reference_data, f, indent=2, separators=(',', ': '))
        
        print(f"    → {output_file}")
    
    # Generate random Clifford+T circuits
    print("\n2. Generating random Clifford+T circuits...")
    random_circuits = generate_random_clifford_t_circuits()
    
    for name, circuit, description in random_circuits:
        print(f"  - {name}: {description}")
        
        # Simulate circuit
        state_vector = simulate_circuit(circuit)
        
        # Convert to JSON format
        amplitudes = complex_to_json_array(state_vector)
        
        # Create metadata
        metadata = {
            "name": name,
            "description": description,
            "num_qubits": circuit.num_qubits,
            "num_gates": len(circuit.data),
            "qiskit_version": qiskit.__version__,
            "circuit_qasm": str(circuit),
            "seed": 42  # For reproducibility
        }
        
        # Create JSON structure
        reference_data = {
            "metadata": metadata,
            "amplitudes": amplitudes
        }
        
        # Write to file
        output_file = output_dir / f"{name}.json"
        with open(output_file, 'w') as f:
            json.dump(reference_data, f, indent=2, separators=(',', ': '))
        
        print(f"    → {output_file}")
    
    print(f"\n✓ Generated {len(canonical_circuits) + len(random_circuits)} reference state files")
    print(f"✓ All files saved to: {output_dir}")


def main():
    """Main entry point."""
    print("Quantum Simulator Reference State Generator")
    print("=" * 50)
    
    try:
        generate_reference_states()
        print("\n✓ Reference state generation completed successfully!")
        
    except Exception as e:
        print(f"\n✗ Error generating reference states: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()